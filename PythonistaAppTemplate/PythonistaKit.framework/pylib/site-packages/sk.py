# coding: utf-8

#raise NotImplementedError('Sorry, the `sk` module is not available in this build.')

import _sk
from _sk import *
import re
import json
import inspect

# Imported mostly for custom attribute expressions:
import math, random

class Scene (_sk._Scene):
	def did_load(self):
		pass
	
	@property
	def nodes_by_touch_id(self):
		if not hasattr(self, '_nodes_by_touch_id'):
			self._nodes_by_touch_id = {}
		return self._nodes_by_touch_id
	
	@property
	def handles_node_touches(self):
		if not hasattr(self, '_handles_node_touches'):
			return True
		return self._handles_node_touches
	
	@handles_node_touches.setter
	def handles_node_touches(self, value):
		self._handles_node_touches = value
		
	def _touch_began(self, touch):
		handled = False
		if self.handles_node_touches:
			touched_nodes = self.nodes_at_point(touch.location)
			for n in touched_nodes:
				if n.touch_enabled:
					handled = handled or self.touch_began(n, touch)
					self.nodes_by_touch_id[touch.touch_id] = self.nodes_by_touch_id.get(touch.touch_id, []) + [n]
		if not handled:
			self.touch_began(self, touch)
			
	def _touch_moved(self, touch):
		handled = False
		for node in self.nodes_by_touch_id.get(touch.touch_id, []):
			handled = handled or self.touch_moved(node, touch)
		if not handled:
			self.touch_moved(self, touch)
		
	def _touch_ended(self, touch):
		handled = False
		for node in self.nodes_by_touch_id.get(touch.touch_id, []):
			handled = handled or self.touch_ended(node, touch)
		if self.nodes_by_touch_id.get(touch.touch_id, None):
			del self.nodes_by_touch_id[touch.touch_id]
		if not handled:
			self.touch_ended(self, touch)
	
	def touch_began(self, node, touch):
		pass
		
	def touch_moved(self, node, touch):
		pass
		
	def touch_ended(self, node, touch):
		pass

_color_pattern = re.compile(r'RGBA\((\d+\.?\d*),\s*(\d+\.?\d*),\s*(\d+\.?\d*),\s*(\d+\.?\d*)\)')
def _color_from_string(s):
	m = re.search(_color_pattern, s) if s else None
	return (float(m.group(1)), float(m.group(2)), float(m.group(3)), float(m.group(4))) if m else None

node_types = {'Sprite': SpriteNode,
              'Label': LabelNode,
              'Emitter': EmitterNode,
              'Light': LightNode,
              'EffectNode': EffectNode} 

def node_from_dict(node_dict, scene=None, f_globals=None, texture_cache={}):
	d = node_dict.get('attributes', {})
	node_type = d.get('_type')
	custom_class_name = d.get('customClass')
	NodeClass = node_types.get(node_type, Node)
	if custom_class_name and f_globals:
		CustomNodeClass = f_globals.get(custom_class_name, None)
		if not inspect.isclass(CustomNodeClass):
			print 'Warning: Could not resolve class name %s' % (custom_class_name,)
		elif not issubclass(CustomNodeClass, NodeClass):
			print 'Warning: %s is not a subclass of %s, ignoring...' % (CustomNodeClass, NodeClass)
		else:
			NodeClass = CustomNodeClass
	
	node = NodeClass()
	if node_type == 'Sprite':
		node.color = _color_from_string(d.get('color'))
		node.color_blend_factor = d.get('colorBlendFactor', 1.0)
		node.blend_mode = d.get('blendMode', 0)
		texture_name = d.get('texture', None)
		if texture_name:
			texture = texture_cache.get(texture_name)
			if not texture:
				texture = Texture(texture_name)
				texture_cache[texture_name] = texture
			node.texture = texture
		node.size = d.get('size.width', 64), d.get('size.height', 64)
		node.lighting_bit_mask = d.get('lightingBitMask', 0xffffffff)
		node.shadow_cast_bit_mask = d.get('shadowCastBitMask', 0x00000000)
		if node.texture and d.get('generateNormalMap', False):
			smoothness = d.get('normalMapSmoothness', 0.0)
			contrast = d.get('normalMapContrast', 1.0)
			node.normal_texture = node.texture.generate_normal_map(smoothness, contrast)
		node.center_rect = (d.get('centerRect.x', 0.0), d.get('centerRect.y', 0.0),
                            d.get('centerRect.width', 1.0), d.get('centerRect.height', 1.0))
	elif node_type == 'Label':
		node.text = d.get('text', '')
		node.font_size = d.get('fontSize', 32)
		node.font_name = d.get('fontName', 'Helvetica')
		font_color_string = d.get('fontColor')
		node.font_color = _color_from_string(font_color_string) if font_color_string else 'white'
		node.color = 'white'
		node.color_blend_factor = 1.0
		node.blend_mode = d.get('blendMode', 0)
	elif node_type == 'Emitter':
		node.p_birth_rate = d.get('particleBirthRate', 30)
		node.p_lifetime = d.get('particleLifetime', 2.0)
		node.p_lifetime_range = d.get('particleLifetimeRange', 0.0)
		node.p_speed = d.get('particleSpeed', 75.0)
		node.p_speed_range = d.get('particleSpeedRange', 0.0)
		node.emission_angle = d.get('emissionAngle', 0.0)
		node.emission_angle_range = d.get('emissionAngleRange', math.pi * 2)
		node.p_rotation = d.get('particleRotation', 0.0)
		node.p_rotation_range = d.get('particleRotationRange', 0.0)
		node.p_rotation_speed = d.get('particleRotationSpeed', 0.0)
		node.p_scale = d.get('particleScale', 1.0)
		node.p_scale_range = d.get('particleScaleRange', 0.0)
		node.p_scale_speed = d.get('particleScaleSpeed', 0.0)
		node.p_alpha = d.get('particleAlpha', 1.0)
		node.p_alpha_range = d.get('particleAlphaRange', 0.0)
		node.p_alpha_speed = d.get('particleAlphaSpeed', 0.0)
		p_color_string = d.get('particleColor')
		node.p_color = _color_from_string(p_color_string) if p_color_string else 'white'
		node.p_color_blend_factor = d.get('particleColorBlendFactor', 1.0)
		node.p_color_blend_factor_range = d.get('particleColorBlendFactorRange', 0.0)
		node.p_color_blend_factor_speed = d.get('particleColorBlendFactorSpeed', 0.0)
		node.p_color_red_range = d.get('particleColorRedRange', 0.0)
		node.p_color_red_speed = d.get('particleColorRedSpeed', 0.0)
		node.p_color_green_range = d.get('particleColorGreenRange', 0.0)
		node.p_color_green_speed = d.get('particleColorGreenSpeed', 0.0)
		node.p_color_blue_range = d.get('particleColorBlueRange', 0.0)
		node.p_color_blue_speed = d.get('particleColorBlueSpeed', 0.0)
		node.p_color_alpha_range = d.get('particleColorAlphaRange', 0.0)
		node.p_color_alpha_speed = d.get('particleColorAlphaSpeed', 0.0)
		node.p_blend_mode = d.get('particleBlendMode', 0)
		node.x_acceleration = d.get('xAcceleration', 0.0)
		node.y_acceleration = d.get('yAcceleration', 0.0)
		node.p_z_position = d.get('particleZPosition', 0)
		node.p_z_position_range = d.get('particleZPositionRange', 0.0)
		node.p_z_position_speed = d.get('particleZPositionSpeed', 0.0)
		node.p_position_range = d.get('particlePositionRange.x', 0.0), d.get('particlePositionRange.y', 0.0)
		node.p_size = d.get('particleSize.width', 0.0), d.get('particleSize.height', 0.0)
		p_texture_name = d.get('particleTexture')
		if p_texture_name:
			texture = texture_cache.get(p_texture_name)
			if not texture:
				texture = Texture(p_texture_name)
				texture_cache[p_texture_name] = texture
			node.p_texture = texture
		if scene:
			target_node_is_scene = d.get('targetNodeIsScene', False)
			if target_node_is_scene:
				node.target_node = scene
	elif node_type == 'Light':
		node.enabled = d.get('enabled', True)
		node.ambient_color = _color_from_string(d.get('ambientColor', None))
		node.light_color = _color_from_string(d.get('lightColor', None))
		#node.shadow_color = _color_from_string(d.get('shadowColor', None))
		node.falloff = d.get('falloff', 1.0)
		node.category_bit_mask = d.get('categoryBitMask', 0x00000001)
	elif node_type == 'EffectNode':
		node.blend_mode = d.get('blendMode', 0)
		filter_name = d.get('filterName', None)
		if filter_name:
			filter = Filter(filter_name)
			filter_attributes = node_dict.get('filterAttributes')
			for key, value in filter_attributes.iteritems():
				filter.set_filter_attr(key, value)
			node.filter = filter
	
	node.position = d.get('position.x'), d.get('position.y')
	node.x_scale = d.get('xScale', 1.0)
	node.y_scale = d.get('yScale', 1.0)
	node.z_rotation = d.get('zRotation', 0.0)
	node.alpha = d.get('alpha', 1.0)
	node.name = d.get('name', '')
	node.touch_enabled = d.get('touchEnabled', False)
	
	physics_attributes = node_dict.get('physicsAttributes', {})
	body_type = physics_attributes.get('bodyType', None)
	body = None
	if body_type == 'Rect':
		rect_size = physics_attributes.get('rectSize', {})
		rect_width, rect_height = rect_size.get('width', 1), rect_size.get('height', 1)
		center = physics_attributes.get('offset', {})
		center_x, center_y = center.get('x', 0), center.get('y', 0)	
		body = PhysicsBody.rect(rect_width, rect_height, (center_x, center_y))
	elif body_type == 'Circle':
		radius = physics_attributes.get('circleRadius', 1)
		center = physics_attributes.get('offset', {})
		center_x, center_y = center.get('x', 0), center.get('y', 0)
		body = PhysicsBody.circle(radius, (center_x, center_y))
	elif body_type == 'EdgeLoopRect':
		rect_size = physics_attributes.get('rectSize', {})
		rect_width, rect_height = rect_size.get('width', 1), rect_size.get('height', 1)
		offset = physics_attributes.get('offset', {})
		offset_x, offset_y = offset.get('x', 0), offset.get('y', 0)
		body = PhysicsBody.edge_loop_rect(-rect_width * 0.5 + offset_x, -rect_height * 0.5 + offset_y, rect_width, rect_height)
	elif body_type == 'Texture':
		texture_name = physics_attributes.get('physicsBodyTexture', None)
		if texture_name:
			texture = texture_cache.get(texture_name)
			if not texture:
				texture = Texture(texture_name)
				texture_cache[texture_name] = texture
			body = PhysicsBody.from_texture(texture)
	if body:
		body.dynamic = physics_attributes.get('dynamic', True)
		body.affected_by_gravity = physics_attributes.get('affectedByGravity', True)
		body.allows_rotation = physics_attributes.get('allowsRotation', True)
		body.density = physics_attributes.get('density', 1.0)
		body.friction = physics_attributes.get('friction', 1.0)
		body.restitution = physics_attributes.get('restitution', 0.2)
		body.linear_damping = physics_attributes.get('linearDamping', 0.15)
		body.angular_damping = physics_attributes.get('angularDamping', 0.15)
		body.uses_precise_collision_detection = physics_attributes.get('usesPreciseCollisionDetection', False)
		body.category_bit_mask = physics_attributes.get('categoryBitMask', 0xffffffff)
		body.collision_bit_mask = physics_attributes.get('collisionBitMask', 0xffffffff)
		body.contact_test_bit_mask = physics_attributes.get('contactTestBitMask', 0x00000000)
		node.physics_body = body
		
	custom_attributes_str = d.get('userData', None)
	if custom_attributes_str:
		try:
			attr_dict = eval(custom_attributes_str, globals(), {'self': node})
			if isinstance(attr_dict, dict):
				for key, value in attr_dict.iteritems():
					setattr(node, key, value)
			else:
				print 'Warning: Ignoring custom attributes (not a dict): %s' % (attr_dict,)
		except Exception, e:
			raise ValueError('Could not load custom attributes: ' + str(e))
	
	child_dicts = node_dict.get('children', [])
	for child_dict in child_dicts:
		node.add_child(node_from_dict(child_dict, f_globals=f_globals, texture_cache=texture_cache))
	
	return node
	
def load(filename_or_dict, parent=None):
	if parent is None:
		parent = Scene()
	elif not isinstance(parent, Node):
		raise TypeError('parent must be a Node or None')
	if isinstance(filename_or_dict, dict):
		json_dict = filename_or_dict
	elif isinstance(filename_or_dict, basestring):
		with open(filename_or_dict, 'r') as f:
			json_dict = json.load(f)
			if not isinstance(json_dict, dict):
				raise TypeError('Root element must be dict')
	else:
		raise TypeError('Expected filename or dict')
	children_dicts = json_dict.get('children', [])
	frame = inspect.currentframe()
	texture_cache = {}
	try:
		f_globals = frame.f_back.f_globals
		for node_dict in children_dicts:
			loaded_node = node_from_dict(node_dict, scene=(parent if isinstance(parent, Scene) else None), f_globals=f_globals, texture_cache=texture_cache)
			parent.add_child(loaded_node)
	finally:
		del frame
	if isinstance(parent, Scene):
		parent.background_color = _color_from_string(json_dict.get('backgroundColor'))
	try:
		parent.did_load()
	except AttributeError:
		pass
	return parent
